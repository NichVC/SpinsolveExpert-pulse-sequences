#########################################################
# 
# Carbon_SincCos_TIMESERIES_dec
#  
# Made by NVC, last updated 10-08-2021
# 
# A pulse sequence for performing a Hyperpolarized Timeseries 
# experiment, with the selective Sinc-Cos pulse + Decoupling.
#
# pulse - delay - acq w/dec
#
# Copyright (c) Magritek Ltd 2021
#
# U.I. V5
#########################################################

#########################################################
# 
# The is the entry point for the SpinsolveExpert 
# interface. It will add the experiment to the parameter
# list or with the control key pressed open the
# relevant macros in the pulse program compiler.
#
# Autogenerated 
#
#########################################################

procedure(Carbon_SincCos_TIMESERIES_dec, parameters=null)

   macroLocation = getmacropath()
   parentPath = getbasepath(macroLocation)
   ppGroup = getbasedir(parentPath)

   if(iskeypressed("shift"))
      PulseProgramCompiler(guiwinnr(),null,parentPath,"Carbon_SincCos_TIMESERIES_dec")
   elseif(iskeypressed("control"))
      gView->showExperimentHelp("Carbon_SincCos_TIMESERIES_dec")
   else
      gExpt->addExperiment(ppGroup,"Carbon_SincCos_TIMESERIES_dec",parameters)
   endif

endproc()

#########################################################
# 
# Provide a backdoor interface to this macro. This 
# adds [""] to the user interface list (guipar)
# and also generates the pulse program lists required 
# by execpp. Finally is calls execpp, returning any
# results in the structure 'r'.
#
# Autogenerated 
#
#########################################################

procedure(backdoor, guipar)

   seqInfo = :getseqpar()  
   r = gSeq->initAndRunPP(getmacropath(), getmacroname(), guipar, seqInfo)

endproc(r)

#########################################################
# 
# Returns important pulse sequence parameter lists
#
# rel ......... relationship between pulse sequence parameters
# var ......... variable which change during the pulse sequence
# pp_list ..... list of pulse sequence parameters sent to DSP
# pp_name ..... name of DSP pulse program to run
# phase_list .. phase cycling information
#
# Autogenerated 
#
#########################################################

procedure(getseqpar)

   rel = ["b1Freq = b1Freq13C",
          "n1 = steps",
          "d1 = stepLength",
          "waltzDuration = WALTZ16:duration(pulseLengthH180/2,pgo)",
          "(t1,t2) = Carbon_SincCos_TIMESERIES_dec:calculateTables(maxAmplitude,steps)",
          "nDataPnts  = nrPnts",
          "offFreq13C  = (centerFreqPPM-wvPPMOffset13C)*b1Freq13C",
          "O1         = offFreq13C",
          "freq13C       = double(b1Freq13C)+double(offFreq13C/1e6d)",
          "freq1H        = double(b1Freq1H)",
          "dPreAcq       = preacqDelay",
          "totPnts    = nrPnts",
          "totTime    = acqTime",
          "aDEC          = decoupleAmp",
          "d90           = pulseLengthH180/2",
          "d180          = pulseLengthH180",
          "d270          = 3*pulseLengthH180/2",
          "d360          = 2*pulseLengthH180",
          "n2            = trunc(1000*acqTime/waltzDuration)+1"]
   var = [""]
   pp_list = ["nDataPnts","freq1H","freq13C","t1","t2","p1","n1","d1","dPreAcq","n2","l1","aDEC","p3","d270","p2","d360","d180","d90"]
   pp_name = "Carbon_SincCos_TIMESERIES_dec.p"
   phase_list = [0,2,0,2;0,0,2,2;2,2,0,0;0,2,0,2]

   seqInfo = struct(rel,var,pp_list,pp_name,phase_list)

endproc(seqInfo)

#########################################################
# Execute the pulse program, collecting nrScans of 
# data and displaying the result in the 1D plot. 
#
# This procedure can be modified to perform more
# complex functions using the passed parameters:
#
# guipar ..... all parameters from the user interface
# ppList ..... the pulse program parameter list
# pcList ..... phase-cycle list
# pcIndex .... indices of phase parameters in ppList
# varIndex ... indices of variable parameters in ppList
#
# 13-Oct-2019 CDE
#########################################################

procedure(execpp,guipar,ppList,pcList,pcIndex,varIndex)

# Make all gui parameters available
   assignlist(guipar)

# Calculate suitable time and frequency axes
   tAxis = ([0:1:totPnts-1]/totPnts)*totTime*1000 # ms
   fAxis = [-totPnts*zf/2:totPnts*zf/2-1]/(totTime*zf)*1000 # Hz

# Time domain filter
   if(filter == "yes")
      flt = filters:get_filter(filterType,"FTFid",totPnts)
   else
      flt = matrix(totPnts)+1
   endif

# Get plot regions
   (prt,prf,prs) = ucsPlot:getPlotRegions(guipar,3,wvPP)

# Work out frequency axis scale, label and range
   (fAxisDisp,fAxisLabel,fRange) = ucsPlot:generate1DFrequencyAxis(prf, fAxis, b1Freq13C, wvPPMOffset13C, offFreq13C, guipar)

# Initialise progress bar
   :updateProgress(0,0,guipar)

# Calculate the timeseries matrix
   timeseries = linspace(0, (timeseriesSteps-1)*(repTime+acqTime+steps*stepLength/1000), timeseriesSteps)

# Storage for the fids and spectra
   fid2d = cmatrix(totPnts, timeseriesSteps)
   spectra = cmatrix(totPnts*zf, timeseriesSteps)
   t_list = matrix(timeseriesSteps)

# Vary the pulse duration scans
   t_start = time()
   for(stepNr = 0 to timeseriesSteps-1)

   # Wait the RepTime between Steps
      if(stepNr != 0)
         pause(repTime/1000)
      endif

   # Allocate space for output data
      sumData = cmatrix(totPnts)
      
   # Accumulate scans
      for(scan = 0 to nrScans-1)
   
         t1 = time()
   
       # Set phases for this scan
         (ppList,pAcq) = ucsRun:setPPPhase(ppList,scan,pcList,pcIndex)
   
       # Send all parameter values to DSP
          ucsRun:updatePPParameters(ppList,guipar,wvPort)  
   
       # Run the pulse program and collect the data
          ucsUtilities:suspendLock() # turn lock control loop off
         (status,data) = ucsRun:getData(totPnts,guipar)
          ucsUtilities:resumeLock()  # turn lock control loop on
   
       # See if stop button/escape key pressed
         if(status != "ok")
            return(0)
         endif
   
       # Shift the data to minimise p1
         data = shift(data,round(shiftPoints)) 
   
       # Correct the distortions in start of FID due to digital filter 
         data = ucsUtilities:correctFilter1(data,dwellTime)
   
       # Accumlate the data
         sumData = ucsRun:accumulate(accumulate,pAcq,sumData,data)
   
       # Correct the first data point
         datacorr = sumData
         if (shiftPoints == 1)
            datacorr = ucsUtilities:correctFirstPointAmpPhase(sumData)
            datacorr[0] = datacorr[0]/2
         endif
   
      # FID autophase
         phCor = phase(datacorr[0])
         datacorr = datacorr*exp(-i*phCor)
   
       # Process data
         (phasedTimeData,spectrum,ph0) = ucsRun:transformData(zerofill(datacorr.*flt,zf*totPnts,"end"),fAxis,guipar,"fid")

       # Plot the data 
         ucsPlot:graphTimeAndFreq(prt,prf,tAxis,datacorr,fAxisDisp,spectrum,scan,guipar,
                                  "Time data (time step: $time()-t_start$ s)","Spectral data",
                                  "Time (ms)","Amplitude (\G(m)V)",
                                  fAxisLabel,"Amplitude")
   
       # Update progress bar
         :updateProgress(scan, stepNr, guipar)
   
      # Check timing
         check = ucsRun:checkTimeAndAbort(guipar,t1,scan,pcList,"ignoreLastScan")
         if(check == "abort")
            return(0)
         elseif(check == "finish")
            scan = scan+1
            exitfor()
         endif
   
      next(scan)

     # Save the FID and Spectrum
      fid2d[~,stepNr] = sumData
      spectra[~,stepNr] = spectrum
      t_list[stepNr] = time()-t_start

     # Display the spectra collected so far
      StackedPlot(prs,  real(spectra), stepNr, fRange, fAxisDisp, "yes", timeseries/1000, 
                  "linear", "Frequency (ppm)", "Timeseries approx. (s)","Timeseries")

     # Check for finish
      if(check == "finish")  
         exitfor() 
      endif

   next(stepNr) # Next pulse duration step

# Save the data
   ucsFiles:savePlot(prs,:getPlotInfo("pt3"),guipar,"noReport")
   ucsFiles:saveMNovaData(fid2d,"",guipar,"simpleReport")

# Save the processing parameters
   :saveProcPar(guipar,ph0,fRange)

# Save time-list
   cd("$dataDirectory$\\$expName$")
   save("timelist.1d",t_list)

# Pack the data into a structure
   result = struct()
   result->tAxis = tAxis
   result->tData = sumData/scan
   result->fAxis = fAxisDisp
   result->fData = spectrum/scan
   result->par = struct(guipar)

# Return result
   return(result)

endproc("execpp") # Don't remove argument

#####################################################
# Assign those parameters which should take their 
# values from the factory defaults when making a 
# new experiment
#####################################################

procedure(getFactoryBasedParameters, par)

   specPar = SpinsolveParameterUpdater:readDSPPar(null)
   if(specPar == null)
      return(null)
   endif
   assignlist(specPar)

   modelPar = ucsUtilities:getModelBasedParameters("13C",specPar)

   (shiftPoints, preacqDelay) = :getPreAcquDelay(8000, modelPar->dwellTime)

   par = ["b1Freq13C       = $Frequency_X$",
          "pulseLengthH180 = $PulseLength_1H_Decouple$",
          "decoupleAmp     = $PowerLevel_1H_Decouple$",
          "preacqDelay     = $preacqDelay$",
          "b1Freq1H        = $Frequency_1H$",
          "shiftPoints     = $shiftPoints$"]

endproc(par)

########################################################
# Calculate the preacquisiton delay
########################################################

procedure(getPreAcquDelay, pulseLength, dwellTime)

   shiftPoints = 0
   preacqDelay = 0

   while(preacqDelay < 20)
      shiftPoints = shiftPoints + 1
      preacqDelay = (shiftPoints - 0.72)*dwellTime - 0.66*pulseLength + 10
   endwhile   

   if(shiftPoints > 3)
      shiftPoints = 3
      preacqDelay = 20
   endif()

endproc(shiftPoints, preacqDelay)

########################################################
# Get the name of a plot file given the region name
# or return the whole list
########################################################

procedure(getPlotInfo,plotRegion)

   info = ["pt3","Carbon_SincCos_TIMESERIES_dec.pt1"]

   if(plotRegion == "all")
      return(info)
   endif

   idx = getlistindex(info,plotRegion)
   if(idx != -1)
      return(info[idx+1])
   endif

endproc(null)


########################################################
# Update the progress bar and experiment times
########################################################

procedure(updateProgress, scans, stepNr, guipar)

# Define progress/timing expressions

   if(isvar("progressCtrl"))

      if(isvar("wvUpdateProgressCtrl"))
         if(wvUpdateProgressCtrl == 0)
            return
         endif
      endif

      assignlist(guipar)

   # Define progress/timing expressions
      totTime = timeseriesSteps*nrScans*repTime/1000
      expTime = (stepNr*nrScans + (scans+1))*repTime/1000
      remTime = totTime - expTime
      progress = 100*expTime/totTime

   # Update controls
     ucsCtrl:updateProgress(scans+1,progress,totTime,expTime,remTime)

   endif

endproc()

#################################
# Save the processing parameters
#################################

procedure(saveProcPar,guipar,p0,xrange)

   assignlist(guipar)
  
   if(saveData == "false")
      return
   endif

   if(usePPMScale == "yes")
      xrange = xrange*single(b1Freq13C)
   endif

   procpar = ["apodizationFunction = \"$filterType$\"",
              "baseLineCorrectionMethod = \"None\"",
              "displayInPPM = \"$usePPMScale$\"",
              "ftOrigin = \"Start\"",
              "ftType = \"Complex\"",
              "p0Phase = $p0$",
              "p1Phase = 0",
              "p1Pivot = 0",
              "p1FixedPhase = 0",
              "phaseMethod = \"p0, p1 fixed phase\"",
              "zeroFill = $zf$",
              "plotWidth = $xrange[1]-xrange[0]$",
              "plotStart = $xrange[0]$",
              "shiftPoints = 1"]

   cd("$dataDirectory$\\$expName$")

   if(isfile("proc.par"))
      par = load("proc.par")
      procpar = mergelists(procpar,par)
   endif

   save("proc.par",procpar)

   if(isfile("proc_temp.par"))
      rmfile("proc_temp.par")
   endif

endproc()

procedure(calculateTables,maxAmplitude,n1)
   cosfreq = 0.1685
   x = linspace(-32,32,n1)
   A = ucsRun:convertTxGain(maxAmplitude)
   s = sin(x)/x.*cos(x*2*pi*cosfreq)
   t1 = A*mag(s)
   t2 = (s<0)*180/360*2^16
endproc(t1,t2)

